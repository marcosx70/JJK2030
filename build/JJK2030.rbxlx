<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">AnimationHandler</string>
          <string name="Source"></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">DashHandler</string>
          <string name="Source"></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">InputConfig</string>
          <string name="Source"><![CDATA[-- InputConfig.lua
-- Configurable key bindings with runtime rebinding support

local InputConfig = {}

-- Default key bindings
local defaultKeys = {
	Jump = Enum.KeyCode.Space,
	Sprint = Enum.KeyCode.LeftShift,
	Dash = Enum.KeyCode.E,
	Forward = Enum.KeyCode.W,
	Backward = Enum.KeyCode.S,
	Left = Enum.KeyCode.A,
	Right = Enum.KeyCode.D,
}

-- Active key mappings (mutable)
InputConfig.Keys = table.clone(defaultKeys)

-- Rebind a key at runtime
function InputConfig.SetKey(actionName, newKeyCode)
	if not defaultKeys[actionName] then
		warn("[InputConfig] Invalid action name:", actionName)
		return
	end
	if typeof(newKeyCode) ~= "EnumItem" or newKeyCode.EnumType ~= Enum.KeyCode then
		warn("[InputConfig] Invalid key code:", newKeyCode)
		return
	end

	InputConfig.Keys[actionName] = newKeyCode
end

-- Reset key to default
function InputConfig.ResetKey(actionName)
	if defaultKeys[actionName] then
		InputConfig.Keys[actionName] = defaultKeys[actionName]
	end
end

-- Reset all keys to default
function InputConfig.ResetAll()
	InputConfig.Keys = table.clone(defaultKeys)
end

-- Get currently assigned key
function InputConfig.GetKey(actionName)
	return InputConfig.Keys[actionName] or defaultKeys[actionName]
end

-- Expose defaults (read-only)
InputConfig.Defaults = table.clone(defaultKeys)

return InputConfig
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">StateManager</string>
          <string name="Source"><![CDATA[-- StateManager.lua
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local StateChangedRemote = ReplicatedStorage:WaitForChild("StateChangedRemote")
local StateChanged = Instance.new("BindableEvent")

local StateManager = {}
local PlayerStates = {}
local StateHistory = {}

-- Define allowed states per layer
local AllowedStates = {
    Movement = { Idle = true, Walking = true, Sprinting = true, Jumping = true, AirDash = true, AerialCombat = true },
    Action = { None = true, Attacking = true, Blocking = true },
    Combat = { Neutral = true, Engaged = true }
}

local function validateState(layer, state)
    return AllowedStates[layer] and AllowedStates[layer][state]
end

Players.PlayerAdded:Connect(function(player)
    PlayerStates[player] = {
        Movement = "Idle",
        Action = "None",
        Combat = "Neutral"
    }
    StateHistory[player] = {
        Movement = { "Idle" },
        Action = { "None" },
        Combat = { "Neutral" }
    }
end)

Players.PlayerRemoving:Connect(function(player)
    PlayerStates[player] = nil
    StateHistory[player] = nil
end)

function StateManager:Set(player, layer, state)
    assert(typeof(player) == "Instance" and player:IsA("Player"), "Invalid player.")
    assert(PlayerStates[player], "Player not tracked.")
    assert(validateState(layer, state), "Invalid state for layer: " .. layer)

    PlayerStates[player][layer] = state
    table.insert(StateHistory[player][layer], state)

    StateChanged:Fire(player, layer, state)
    StateChangedRemote:FireClient(player, layer, state)
end

function StateManager:Revert(player, layer)
    local history = StateHistory[player] and StateHistory[player][layer]
    if history and #history > 1 then
        table.remove(history)
        local previousState = history[#history]
        PlayerStates[player][layer] = previousState
        StateChanged:Fire(player, layer, previousState)
        StateChangedRemote:FireClient(player, layer, previousState)
    end
end

function StateManager:Get(player, layer)
    return PlayerStates[player] and PlayerStates[player][layer]
end

function StateManager:IsInState(player, layer, stateList)
    local current = self:Get(player, layer)
    for _, state in ipairs(stateList) do
        if state == current then return true end
    end
    return false
end

function StateManager:GetAll(player)
    local stateCopy = {}
    for layer, state in pairs(PlayerStates[player] or {}) do
        stateCopy[layer] = state
    end
    return stateCopy
end

function StateManager:GetHistory(player, layer)
    return table.clone(StateHistory[player] and StateHistory[player][layer] or {})
end

function StateManager:GetEvent()
    return StateChanged.Event
end

return StateManager
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">StyleLoader</string>
          <string name="Source"><![CDATA[-- StyleLoader.lua
-- Loads and manages fighting style animation overrides

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local StyleLoader = {}

local defaultAnimations = {
	Idle = "rbxassetid://DEFAULT_IDLE_ANIM",
	Run = "rbxassetid://DEFAULT_RUN_ANIM",
	Attack = "rbxassetid://DEFAULT_ATTACK_ANIM"
}

-- Replace with actual style animations
local styles = {
	Karate = {
		Idle = "rbxassetid://KARATE_IDLE",
		Run = "rbxassetid://KARATE_RUN",
		Attack = "rbxassetid://KARATE_ATTACK"
	},
	Boxing = {
		Idle = "rbxassetid://BOXING_IDLE",
		Run = "rbxassetid://BOXING_RUN",
		Attack = "rbxassetid://BOXING_ATTACK"
	}
}

-- Placeholder for player style registry
local playerStyles = {}

-- Called once when player joins
function StyleLoader.SetStyle(player, styleName)
	if styles[styleName] then
		playerStyles[player] = styleName
	else
		warn("Unknown style: " .. tostring(styleName))
	end
end

function StyleLoader.GetStyle(player)
	return playerStyles[player] or "Default"
end

function StyleLoader.GetAnimation(player, action)
	local style = StyleLoader.GetStyle(player)
	local styleSet = styles[style] or defaultAnimations
	return styleSet[action] or defaultAnimations[action]
end

-- Optional cleanup
Players.PlayerRemoving:Connect(function(player)
	playerStyles[player] = nil
end)

return StyleLoader
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="7">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="8">
      <Properties>
        <string name="Name">Server</string>
      </Properties>
      <Item class="ModuleScript" referent="9">
        <Properties>
          <string name="Name">KeybindSaver</string>
          <string name="Source"><![CDATA[-- KeybindSaver.lua
-- Handles saving and loading of player keybinds using DataStoreService

local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")

local KeybindStore = DataStoreService:GetDataStore("PlayerKeybinds")

-- Configuration
local DEFAULT_KEYBINDS = {
	Jump = Enum.KeyCode.Space.Name,
	Sprint = Enum.KeyCode.LeftShift.Name,
	Dash = Enum.KeyCode.Q.Name,
	Forward = Enum.KeyCode.W.Name,
	Backward = Enum.KeyCode.S.Name,
	Left = Enum.KeyCode.A.Name,
	Right = Enum.KeyCode.D.Name
}

local function loadKeybinds(userId)
	local data
	local success, err = pcall(function()
		data = KeybindStore:GetAsync(tostring(userId))
	end)

	if success and data then
		return data
	else
		return DEFAULT_KEYBINDS
	end
end

local function saveKeybinds(userId, bindings)
	pcall(function()
		KeybindStore:SetAsync(tostring(userId), bindings)
	end)
end

Players.PlayerAdded:Connect(function(player)
	local keybinds = loadKeybinds(player.UserId)

	local remoteFolder = Instance.new("Folder")
	remoteFolder.Name = "Remotes"
	remoteFolder.Parent = player

	local loadRemote = Instance.new("RemoteFunction")
	loadRemote.Name = "RequestKeybinds"
	loadRemote.Parent = remoteFolder

	loadRemote.OnServerInvoke = function()
		return keybinds
	end

	local saveRemote = Instance.new("RemoteEvent")
	saveRemote.Name = "SaveKeybinds"
	saveRemote.Parent = remoteFolder

	saveRemote.OnServerEvent:Connect(function(_, bindings)
		if typeof(bindings) == "table" then
			saveKeybinds(player.UserId, bindings)
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	-- Optional: Save here if you want autosave fallback
end)
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="10">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterCharacterScripts" referent="11">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">PlayerMovementController</string>
          <string name="Source"><![CDATA[-- PlayerMovementController.lua
-- Handles player input, movement states, and animation triggers

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local InputConfig = require(game.ReplicatedStorage.Shared.InputConfig)
local StateManager = require(game.ReplicatedStorage.Shared.StateManager)

-- Handle character respawn
local function refreshCharacter()
	character = player.Character or player.CharacterAdded:Wait()
	humanoid = character:WaitForChild("Humanoid")
end

player.CharacterAdded:Connect(refreshCharacter)

local movementDirection = Vector3.zero
local isSprinting = false
local isJumping = false

-- Update direction vector and state
local function updateMovementDirection()
	local direction = Vector3.zero

	if UserInputService:IsKeyDown(InputConfig.Keys.Forward) then
		direction += Vector3.new(0, 0, -1)
	end
	if UserInputService:IsKeyDown(InputConfig.Keys.Backward) then
		direction += Vector3.new(0, 0, 1)
	end
	if UserInputService:IsKeyDown(InputConfig.Keys.Left) then
		direction += Vector3.new(-1, 0, 0)
	end
	if UserInputService:IsKeyDown(InputConfig.Keys.Right) then
		direction += Vector3.new(1, 0, 0)
	end

	if direction.Magnitude > 0 then
		movementDirection = direction.Unit
		local state = isSprinting and "Sprinting" or "Running"
		StateManager:Set(player, "Movement", state)
	else
		movementDirection = Vector3.zero
		StateManager:Set(player, "Movement", "Idle")
	end
end

-- Input begin handler
UserInputService.InputBegan:Connect(function(input, isProcessed)
	if isProcessed then return end

	if input.KeyCode == InputConfig.Keys.Sprint then
		isSprinting = true
	elseif input.KeyCode == InputConfig.Keys.Jump then
		isJumping = true
		StateManager:Set(player, "Movement", "Jumping")
	end
end)

-- Input end handler
UserInputService.InputEnded:Connect(function(input)
	if input.KeyCode == InputConfig.Keys.Sprint then
		isSprinting = false
	elseif input.KeyCode == InputConfig.Keys.Jump then
		isJumping = false
	end
end)

-- Frame-based checks
RunService.RenderStepped:Connect(function()
	updateMovementDirection()

	if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
		StateManager:Set(player, "Movement", "Freefall")
	end
end)
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>